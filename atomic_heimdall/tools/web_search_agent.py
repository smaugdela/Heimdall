# web_search_agent.py

import os
from typing import List, Optional
import instructor
from pydantic import Field # Import BaseModel explicitly

from atomic_agents.agents.base_agent import BaseAgent, BaseAgentConfig
from atomic_agents.lib.base.base_io_schema import BaseIOSchema
from atomic_agents.lib.components.agent_memory import AgentMemory
from atomic_agents.lib.components.system_prompt_generator import SystemPromptGenerator

import openai

# Import the provided tools and their schemas
# Assuming tools are in a 'tools' directory relative to this script
try:
    from tools.webpage_scraper_tool import (
        WebpageScraperTool,
        WebpageScraperToolConfig,
        WebpageScraperToolInputSchema,
        WebpageScraperToolOutputSchema,
    )
    from tools.websearch_tool import (
        DuckDuckGoSearchTool,
        DuckDuckGoSearchToolConfig,
        DuckDuckGoSearchToolInputSchema,
        DuckDuckGoSearchToolOutputSchema,
    )
except ImportError as e:
    print(f"Error importing tools: {e}")
    print("Please ensure 'tools/webpage_scraper_tool.py' and 'tools/websearch_tool.py' exist and are accessible.")
    exit(1)


from dotenv import load_dotenv, find_dotenv
from rich.console import Console
from rich.panel import Panel
from rich.syntax import Syntax
from rich.markdown import Markdown

# Load environment variables from a .env file (searches upwards from the script location)
load_dotenv(find_dotenv())

### GEMINI CLIENT INITIALIZATION ###
try:
    api_key = os.getenv("GEMINI_API_KEY")
    if not api_key:
        print("Error: No API key found. Please set GEMINI_API_KEY in your environment or a .env file.")
        exit(42)
    # Use instructor with the OpenAI-compatible Gemini API endpoint
    client = instructor.from_openai(
        openai.OpenAI(
            api_key=api_key,
            base_url="https://generativelanguage.googleapis.com/v1beta/openai/",
        ),
        mode=instructor.Mode.JSON,
    )
    model = "models/gemini-2.0-flash-lite" # Specify the Gemini model name
except Exception as e:
    print(f"Error initializing Gemini client: {e}")
    exit(42)

### MISTRAL CLIENT INITIALIZATION ###
# try:
#     api_key = os.getenv("MISTRAL_API_KEY")
#     if not api_key:
#         print("Error: Mistral API key not found. Cannot initialize any client.")
#         exit(42)
#     client = instructor.from_openai(
#         openai.OpenAI(
#             api_key=api_key,
#             base_url="https://api.mistral.ai/v1/",
#         ),
#         mode=instructor.Mode.JSON,
#     )
#     model = "mistral-small" # Specify the Mistral model name
#     print("Using Mistral client.")
# except Exception as e:
#     print(f"Error initializing Mistral client: {e}")
#     print("Cannot initialize any client. Exiting.")
#     exit(42)

### OPENAI CLIENT INITIALIZATION ###
# try:
#     api_key = os.getenv("OPENAI_API_KEY")
#     if not api_key:
#         print("Error: OpenAI API key not found. Cannot initialize any client.")
#         exit(1)
#     client = instructor.from_openai(openai.OpenAI(api_key=api_key))
#     model = "gpt-4o-mini" # Specify the OpenAI model name
#     print("Using OpenAI client.")
# except Exception as e:
#     print(f"Error initializing OpenAI client: {e}")
#     print("Cannot initialize any client. Exiting.")
#     exit(42)

### LOCAL OLLAMA CLIENT INITIALIZATION ###
# try:
#     model = "qwen2.5" # Specify the local model name
#     client = instructor.from_openai(
#         openai.OpenAI(
#             api_key="ollama",
#             base_url="http://localhost:11434/v1",
#         ),
#         mode=instructor.Mode.JSON,
#     )
#     print("Using local Ollama client.")
# except Exception as e:
#     print(f"Error initializing local Ollama client: {e}")
#     print("Cannot initialize any client. Exiting.")
#     exit(42)


########################
# INPUT/OUTPUT SCHEMAS #
########################

class UserQueryInputSchema(BaseIOSchema):
    """Input schema for the initial user query."""
    query: str = Field(..., description="The user's natural language query for web search.")

# QueryGenerationAgent will output DuckDuckGoSearchToolInputSchema

# AnswerSynthesisAgent will take UserQueryInputSchema as input
# and rely on memory for scraped content.

class FinalAnswerOutputSchema(BaseIOSchema):
    """Schema for the final answer generated by the AnswerSynthesisAgent."""
    final_answer: str = Field(..., description="The final answer generated based on the scraped content and user query. It is a single string supporting markdown format.")

# Schema to represent scraped content when adding to memory
class ScrapedContentSchema(BaseIOSchema):
    """Schema for storing scraped content in agent memory."""
    scraped_pages: List[WebpageScraperToolOutputSchema] = Field(
        ..., description="List of scraped webpage contents and metadata."
    )


#####################
# SYSTEM PROMPTS    #
#####################

# System prompt for the first agent: Generating search queries
query_generation_system_prompt = SystemPromptGenerator(
    background=[
        "You are a meticulous query generation agent for a web search system.",
        "Your sole purpose is to analyze a user's natural language query and formulate precise and diverse search terms.",
        "You have access to a DuckDuckGo search tool and must output parameters for it.",
    ],
    output_instructions=[
        "Analyze the user's query carefully to understand the core information needed.",
        "Generate 1 to 3 distinct search queries that cover different angles or aspects of the user's request.",
        "Specify a reasonable maximum number of results for each query (e.g., ~3, never more than 10).",
        "Format your output strictly according to the DuckDuckGoSearchToolInputSchema.",
        "Do NOT attempt to answer the question or perform any other task.",
        "Ensure the 'queries' field is a list of strings.",
        "Ensure the 'max_results' field is an integer.",
        "Optionally, specify the 'category' if the query clearly indicates a need for image or news search (default is 'text').",
    ],
)

# System prompt for the second agent: Synthesizing the final answer
answer_synthesis_system_prompt = SystemPromptGenerator(
    background=[
        "You are a helpful answer synthesis agent.",
        "You have been provided with scraped content from several webpages related to the user's original query.",
        "The input contains a JSON object with a key 'scraped_pages'. The value of 'scraped_pages' is a list of objects.",
        "Each object in the 'scraped_pages' list represents a scraped page and has keys like 'content' (the markdown content) and 'metadata'.",
        "Your task is to read the user's original query and carefully analyze the 'content' from the 'scraped_pages' list in the system message to synthesize a comprehensive, accurate, and concise final answer.",
    ],
    output_instructions=[
        "Review the original user query.",
        "Parse the JSON content of your input to access the 'scraped_pages' list.",
        "For each item in the 'scraped_pages' list, extract the value of the 'content' key.",
        "Synthesize all the extracted 'content' into a single, coherent answer that directly addresses the user's original query.",
        "If the extracted content does not contain sufficient information to fully answer the query, state this limitation in your answer.",
        "Do not directly quote large blocks of text from the scraped content unless absolutely necessary for clarity.",
        "Format your final answer strictly according to the FinalAnswerOutputSchema, ensuring the synthesized answer is a single string in the 'final_answer' field.",
        "You are encouraged to use markdown formatting in your final answer to structure the information.",
        "If you need to include images or any compatible media, provide the URLs in markdown format like so: ![image](<URL>)",
    ],
)

######################
# AGENT DEFINITIONS  #
######################

# Agent 1: Generates search queries
query_generation_agent = BaseAgent(
    BaseAgentConfig(
        client=client,
        model=model,
        system_prompt_generator=query_generation_system_prompt,
        input_schema=UserQueryInputSchema,
        output_schema=DuckDuckGoSearchToolInputSchema, # Outputs parameters for the search tool
        memory=AgentMemory(), # Each agent instance gets its own memory initially
    )
)

# Agent 2: Synthesizes the final answer
answer_synthesis_agent = BaseAgent(
    BaseAgentConfig(
        client=client,
        model=model,
        system_prompt_generator=answer_synthesis_system_prompt,
        input_schema=ScrapedContentSchema,
        output_schema=FinalAnswerOutputSchema, # Outputs the final answer
        memory=AgentMemory(), # Each agent instance gets its own memory initially
    )
)


#################
# EXECUTION FLOW #
#################

def run_web_search_flow(user_query: str, console: Optional[Console]) -> Optional[str]:
    """
    Runs the complete web search and answer synthesis flow for a given user query.

    Args:
        user_query (str): The natural language query from the user.

    Returns:
        Optional[str]: The synthesized final answer, or None if an error occurred.
    """
    if console is None:
        console = Console()

    console.print(f"Using model: {model}")

    # Use a shared memory instance for this specific query run
    # This memory will be passed to both agent instances for this flow
    current_flow_memory = AgentMemory()

    # Re-initialize agents with the specific memory for this run
    query_generation_agent.memory = current_flow_memory
    answer_synthesis_agent.memory = current_flow_memory

    # Initialize tools (can be done once outside this function if preferred)
    duckduckgo_search_tool = DuckDuckGoSearchTool(DuckDuckGoSearchToolConfig())
    webpage_scraper_tool = WebpageScraperTool(WebpageScraperToolConfig())

    console.print(Panel(f"[bold cyan]User Input:[/bold cyan] {user_query}", expand=False))

    # --- Step 1: Query Generation Agent generates search queries ---
    console.print("\n[bold yellow]Step 1: Query Generation Agent generating search queries...[/bold yellow]")
    search_tool_params = None
    try:
        agent_input = UserQueryInputSchema(query=user_query)
        # The agent's output schema is DuckDuckGoSearchToolInputSchema
        search_tool_params: DuckDuckGoSearchToolInputSchema = query_generation_agent.run(agent_input)

        console.print("\n[bold magenta]Generated Search Parameters:[/bold magenta]")
        search_params_syntax = Syntax(
            str(search_tool_params.model_dump_json(indent=2)), "json", theme="monokai", line_numbers=True
        )
        console.print(search_params_syntax)

    except Exception as e:
        console.print(f"[red]Error during search query generation:[/red] {str(e)}")
        # Add error to memory for potential debugging by a meta-agent, or just log
        return None # Cannot proceed without search queries

    # --- Step 2: Execute the search tool ---
    console.print("\n[bold yellow]Step 2: Executing search tool...[/bold yellow]")
    search_results = None
    try:
        # Execute the search tool with the generated parameters
        search_results: DuckDuckGoSearchToolOutputSchema = duckduckgo_search_tool.run(search_tool_params)

        console.print("\n[bold green]Search Results:[/bold green]")
        search_results_syntax = Syntax(
            str(search_results.model_dump_json(indent=2)), "json", theme="monokai", line_numbers=True
        )
        console.print(search_results_syntax)

        if not search_results or not search_results.results:
            console.print("[yellow]No search results found.[/yellow]")
            # We might still proceed to synthesis to state no results were found
            # or return None here if no results means no answer is possible.
            # Let's proceed to synthesis so the agent can report no results.
        # else:
        #     current_flow_memory.add_message("assistant", search_results)

    except Exception as e:
        console.print(f"[red]Error during search execution:[/red] {str(e)}")
        # We might still proceed to synthesis to report the error
        # or return None. Let's proceed.


    # --- Step 3: Scrape relevant search results ---
    console.print("\n[bold yellow]Step 3: Scraping search results...[/bold yellow]")
    scraped_contents: List[WebpageScraperToolOutputSchema] = []
    if search_results and search_results.results:
        for i, result in enumerate(search_results.results):
            console.print(f"[yellow]Scraping URL {i+1}/{len(search_results.results)}: {result.url}[/yellow]")
            webpage_scraper_tool_input = WebpageScraperToolInputSchema(
                url=result.url,
                include_links=True, # Typically don't need links in scraped content for synthesis
            )
            try:
                scraped_result: WebpageScraperToolOutputSchema = webpage_scraper_tool.run(webpage_scraper_tool_input)
                scraped_contents.append(scraped_result)
                console.print(f"[green]Successfully scraped: {result.url}[/green]")
            except Exception as e:
                console.print(f"[red]Error scraping {result.url}: {str(e)}[/red]")
                # Continue to try and scrape other results
                continue

    if not scraped_contents:
         console.print("[yellow]No content was successfully scraped.[/yellow]")

    # --- Add scraped content to memory for the synthesis agent ---
    scraped_data = ScrapedContentSchema(scraped_pages=scraped_contents)
    # Add the structured scraped data to memory under a specific role/tag
    # current_flow_memory.add_message("system", scraped_data)
    # console.print("[green]Scraped content added to memory for synthesis agent.[/green]")


    # --- Step 4: Answer Synthesis Agent generates the final answer ---
    console.print("\n[bold yellow]Step 4: Answer Synthesis Agent generating final answer...[/bold yellow]")
    final_answer = None
    try:
        # Run the synthesis agent with the original user query as input.
        # It will use its system prompt and the scraped content in memory.
        final_answer_output: FinalAnswerOutputSchema = answer_synthesis_agent.run(scraped_data)
        final_answer = Markdown(final_answer_output.final_answer)

        console.print("\n[bold blue]Final Answer:[/bold blue]")
        console.print(final_answer)

    except Exception as e:
        console.print(f"[red]Error during final answer generation:[/red] {str(e)}")
        return None # Indicate failure

    console.print("\n" + "=" * 80 + "\n") # Separator for the next query

    return final_answer


#################
# EXAMPLE USAGE #
#################

if __name__ == "__main__":
    # Example inputs
    user_inputs = [
        # "Who won the last FIFA World Cup?",
        # "Summarize the plot of the movie Inception.",
        # "Tell me what is CVE-2023-4863 and how to exploit it.",
    ]

    # Initialize console for output
    console = Console()

    for user_input_query in user_inputs:
        run_web_search_flow(user_input_query, console)
