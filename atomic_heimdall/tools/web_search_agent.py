import os
from typing import List, Optional
import instructor
from pydantic import Field
import openai
from dotenv import load_dotenv, find_dotenv
from rich.console import Console
from rich.panel import Panel
from rich.syntax import Syntax
from rich.markdown import Markdown

from atomic_agents.agents.base_agent import BaseAgent, BaseAgentConfig
from atomic_agents.lib.base.base_io_schema import BaseIOSchema
from atomic_agents.lib.components.agent_memory import AgentMemory
from atomic_agents.lib.components.system_prompt_generator import SystemPromptGenerator

from tools.webpage_scraper_tool import (
    WebpageScraperTool,
    WebpageScraperToolConfig,
    WebpageScraperToolInputSchema,
    WebpageScraperToolOutputSchema,
)
from tools.websearch_tool import (
    DuckDuckGoSearchTool,
    DuckDuckGoSearchToolConfig,
    DuckDuckGoSearchToolInputSchema,
    DuckDuckGoSearchToolOutputSchema,
)


load_dotenv(find_dotenv())

### GEMINI CLIENT INITIALIZATION ###
try:
    api_key = os.getenv("GEMINI_API_KEY")
    if not api_key:
        print("Error: No API key found. Please set GEMINI_API_KEY in your environment or a .env file.")
        exit(42)
    client = instructor.from_openai(
        openai.OpenAI(
            api_key=api_key,
            base_url="https://generativelanguage.googleapis.com/v1beta/openai/",
        ),
        mode=instructor.Mode.JSON,
    )
    model = "models/gemini-2.0-flash-lite"
except Exception as e:
    print(f"Error initializing Gemini client: {e}")
    exit(42)

### MISTRAL CLIENT INITIALIZATION ###
# try:
#     api_key = os.getenv("MISTRAL_API_KEY")
#     if not api_key:
#         print("Error: Mistral API key not found. Cannot initialize any client.")
#         exit(42)
#     client = instructor.from_openai(
#         openai.OpenAI(
#             api_key=api_key,
#             base_url="https://api.mistral.ai/v1/",
#         ),
#         mode=instructor.Mode.JSON,
#     )
#     model = "mistral-small" # Specify the Mistral model name
#     print("Using Mistral client.")
# except Exception as e:
#     print(f"Error initializing Mistral client: {e}")
#     print("Cannot initialize any client. Exiting.")
#     exit(42)

### OPENAI CLIENT INITIALIZATION ###
# try:
#     api_key = os.getenv("OPENAI_API_KEY")
#     if not api_key:
#         print("Error: OpenAI API key not found. Cannot initialize any client.")
#         exit(1)
#     client = instructor.from_openai(openai.OpenAI(api_key=api_key))
#     model = "gpt-4o-mini" # Specify the OpenAI model name
#     print("Using OpenAI client.")
# except Exception as e:
#     print(f"Error initializing OpenAI client: {e}")
#     print("Cannot initialize any client. Exiting.")
#     exit(42)

### LOCAL OLLAMA CLIENT INITIALIZATION ###
# try:
#     model = "qwen2.5" # Specify the local model name
#     client = instructor.from_openai(
#         openai.OpenAI(
#             api_key="ollama",
#             base_url="http://localhost:11434/v1",
#         ),
#         mode=instructor.Mode.JSON,
#     )
#     print("Using local Ollama client.")
# except Exception as e:
#     print(f"Error initializing local Ollama client: {e}")
#     print("Cannot initialize any client. Exiting.")
#     exit(42)


########################
# INPUT/OUTPUT SCHEMAS #
########################

class UserQueryInputSchema(BaseIOSchema):
    """Input schema for the initial user query."""
    query: str = Field(..., description="The user's natural language query for web search.")

# QueryGenerationAgent will output DuckDuckGoSearchToolInputSchema

# AnswerSynthesisAgent will take UserQueryInputSchema as input
# and rely on memory for scraped content.

class FinalAnswerOutputSchema(BaseIOSchema):
    """Schema for the final answer generated by the AnswerSynthesisAgent."""
    final_answer: str = Field(..., description="The final answer generated based on the scraped content and user query. It is a single string supporting markdown format.")

class ScrapedContentSchema(BaseIOSchema):
    """Schema for storing scraped content in agent memory."""
    scraped_pages: List[WebpageScraperToolOutputSchema] = Field(
        ..., description="List of scraped webpage contents and metadata."
    )


#####################
# SYSTEM PROMPTS    #
#####################

# System prompt for the first agent: Generating search queries
query_generation_system_prompt = SystemPromptGenerator(
    background=[
        "You are a meticulous query generation agent for a web search system.",
        "Your sole purpose is to analyze a user's natural language query and formulate precise and diverse search terms.",
        "You have access to a DuckDuckGo search tool and must output parameters for it.",
    ],
    output_instructions=[
        "Analyze the user's query carefully to understand the core information needed.",
        "Generate 1 to 3 distinct search queries that cover different angles or aspects of the user's request.",
        "Specify a reasonable maximum number of results for each query (e.g., ~3, never more than 10).",
        "Format your output strictly according to the DuckDuckGoSearchToolInputSchema.",
        "Do NOT attempt to answer the question or perform any other task.",
        "Ensure the 'queries' field is a list of strings.",
        "Ensure the 'max_results' field is an integer.",
        "Optionally, specify the 'category' if the query clearly indicates a need for image or news search (default is 'text').",
    ],
)

# System prompt for the second agent: Synthesizing the final answer
answer_synthesis_system_prompt = SystemPromptGenerator(
    background=[
        "You are a helpful answer synthesis agent.",
        "You have been provided with scraped content from several webpages related to the user's original query.",
        "The input contains a JSON object with a key 'scraped_pages'. The value of 'scraped_pages' is a list of objects.",
        "Each object in the 'scraped_pages' list represents a scraped page and has keys like 'content' (the markdown content) and 'metadata'.",
        "Your task is to read the user's original query and carefully analyze the 'content' from the 'scraped_pages' list in the system message to synthesize a comprehensive, accurate, and concise final answer.",
    ],
    output_instructions=[
        "Review the original user query.",
        "Parse the JSON content of your input to access the 'scraped_pages' list.",
        "For each item in the 'scraped_pages' list, extract the value of the 'content' key.",
        "Synthesize all the extracted 'content' into a single, coherent answer that directly addresses the user's original query.",
        "If the extracted content does not contain sufficient information to fully answer the query, state this limitation in your answer.",
        "Do not directly quote large blocks of text from the scraped content unless absolutely necessary for clarity.",
        "Format your final answer strictly according to the FinalAnswerOutputSchema, ensuring the synthesized answer is a single string in the 'final_answer' field.",
        "You are encouraged to use markdown formatting in your final answer to structure the information.",
        "If you need to include images or any compatible media, provide the URLs in markdown format like so: ![image](<URL>)",
    ],
)

######################
# AGENT DEFINITIONS  #
######################

# Agent 1: Generates search queries
query_generation_agent = BaseAgent(
    BaseAgentConfig(
        client=client,
        model=model,
        system_prompt_generator=query_generation_system_prompt,
        input_schema=UserQueryInputSchema,
        output_schema=DuckDuckGoSearchToolInputSchema, # Outputs parameters for the search tool
        memory=AgentMemory(), # Each agent instance gets its own memory initially
    )
)

# Agent 2: Synthesizes the final answer
answer_synthesis_agent = BaseAgent(
    BaseAgentConfig(
        client=client,
        model=model,
        system_prompt_generator=answer_synthesis_system_prompt,
        input_schema=ScrapedContentSchema,
        output_schema=FinalAnswerOutputSchema, # Outputs the final answer
        memory=AgentMemory(), # Each agent instance gets its own memory initially
    )
)


#################
# EXECUTION FLOW #
#################

def run_web_search_flow(user_query: str, console: Optional[Console]) -> Optional[str]:
    """
    Runs the complete web search and answer synthesis flow for a given user query.

    Args:
        user_query (str): The natural language query from the user.

    Returns:
        Optional[str]: The synthesized final answer, or None if an error occurred.
    """
    if console is None:
        console = Console()

    console.print(f"Using model: {model}")

    current_flow_memory = AgentMemory()

    query_generation_agent.memory = current_flow_memory
    answer_synthesis_agent.memory = current_flow_memory

    duckduckgo_search_tool = DuckDuckGoSearchTool(DuckDuckGoSearchToolConfig())
    webpage_scraper_tool = WebpageScraperTool(WebpageScraperToolConfig())

    console.print(Panel(f"[bold cyan]User Input:[/bold cyan] {user_query}", expand=False))

    console.print("\n[bold yellow]Step 1: Query Generation Agent generating search queries...[/bold yellow]")
    search_tool_params = None
    try:
        agent_input = UserQueryInputSchema(query=user_query)
        search_tool_params: DuckDuckGoSearchToolInputSchema = query_generation_agent.run(agent_input)

        console.print("\n[bold magenta]Generated Search Parameters:[/bold magenta]")
        search_params_syntax = Syntax(
            str(search_tool_params.model_dump_json(indent=2)), "json", theme="monokai", line_numbers=True
        )
        console.print(search_params_syntax)

    except Exception as e:
        console.print(f"[red]Error during search query generation:[/red] {str(e)}")
        return None

    console.print("\n[bold yellow]Step 2: Executing search tool...[/bold yellow]")
    search_results = None
    try:
        search_results: DuckDuckGoSearchToolOutputSchema = duckduckgo_search_tool.run(search_tool_params)

        console.print("\n[bold green]Search Results:[/bold green]")
        search_results_syntax = Syntax(
            str(search_results.model_dump_json(indent=2)), "json", theme="monokai", line_numbers=True
        )
        console.print(search_results_syntax)

        if not search_results or not search_results.results:
            console.print("[yellow]No search results found.[/yellow]")
        # else:
        #     current_flow_memory.add_message("assistant", search_results)

    except Exception as e:
        console.print(f"[red]Error during search execution:[/red] {str(e)}")
        # We might still proceed to synthesis to report the error or return None

    console.print("\n[bold yellow]Step 3: Scraping search results...[/bold yellow]")
    scraped_contents: List[WebpageScraperToolOutputSchema] = []
    if search_results and search_results.results:
        for i, result in enumerate(search_results.results):
            console.print(f"[yellow]Scraping URL {i+1}/{len(search_results.results)}: {result.url}[/yellow]")
            webpage_scraper_tool_input = WebpageScraperToolInputSchema(
                url=result.url,
                include_links=True,
            )
            try:
                scraped_result: WebpageScraperToolOutputSchema = webpage_scraper_tool.run(webpage_scraper_tool_input)
                scraped_contents.append(scraped_result)
                console.print(f"[green]Successfully scraped: {result.url}[/green]")
            except Exception as e:
                console.print(f"[red]Error scraping {result.url}: {str(e)}[/red]")
                # Continue to try and scrape other results
                continue

    if not scraped_contents:
         console.print("[yellow]No content was successfully scraped.[/yellow]")

    scraped_data = ScrapedContentSchema(scraped_pages=scraped_contents)

    console.print("\n[bold yellow]Step 4: Answer Synthesis Agent generating final answer...[/bold yellow]")
    final_answer = None
    try:
        final_answer_output: FinalAnswerOutputSchema = answer_synthesis_agent.run(scraped_data)
        final_answer = Markdown(final_answer_output.final_answer)

        console.print("\n[bold blue]Final Answer:[/bold blue]")
        console.print(final_answer)

    except Exception as e:
        console.print(f"[red]Error during final answer generation:[/red] {str(e)}")
        return None

    console.print("\n" + "=" * 80 + "\n")

    return final_answer


#################
# EXAMPLE USAGE #
#################

if __name__ == "__main__":

    user_inputs = [
        "Who won the last FIFA World Cup?",
        "Summarize the plot of the movie Inception.",
        "Tell me what is CVE-2023-4863 and how to exploit it.",
    ]

    console = Console()

    for user_input_query in user_inputs:
        run_web_search_flow(user_input_query, console)
