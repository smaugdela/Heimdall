# web_search_agent.py

import os
import openai
import instructor
from pydantic import Field

from atomic_agents.agents.base_agent import BaseAgent, BaseAgentConfig
from atomic_agents.lib.base.base_io_schema import BaseIOSchema
from atomic_agents.lib.components.agent_memory import AgentMemory
from atomic_agents.lib.components.system_prompt_generator import SystemPromptGenerator

# Import the provided tools and their schemas
# Assuming scraper_tool.py and websearch_tool.py are in the same directory
from tools.webpage_scraper_tool import (
    WebpageScraperTool,
    WebpageScraperToolConfig,
)
from tools.websearch_tool import (
    DuckDuckGoSearchTool,
    DuckDuckGoSearchToolConfig,
    DuckDuckGoSearchToolInputSchema,
    DuckDuckGoSearchToolOutputSchema
)

from dotenv import load_dotenv
from rich.console import Console
from rich.panel import Panel
from rich.syntax import Syntax

# Load environment variables from a .env file
load_dotenv()

# Set up the OpenAI client using instructor for schema validation
# Ensure OPENAI_API_KEY is set in your .env file
try:
    client = instructor.from_openai(openai.OpenAI(api_key=os.getenv("OPENAI_API_KEY")))
except Exception as e:
    print(f"Error initializing OpenAI client: {e}")
    print("Please ensure OPENAI_API_KEY is set in your environment or a .env file.")
    exit()


########################
# INPUT/OUTPUT SCHEMAS #
########################

class WebSearchAgentInputSchema(BaseIOSchema):
    """Input schema for the Web Search Agent. Contains the user's search query."""
    query: str = Field(..., description="The user's natural language query for web search.")

# We will reuse DuckDuckGoSearchToolInputSchema as the output schema for the first step.
# This schema tells the agent how to format the search queries it generates.

# We will reuse DuckDuckGoSearchToolOutputSchema as input for the second step via memory.
# We need to ensure the agent can interpret this structure when it's in memory.

# Schema for the final answer (matches the example)
class FinalAnswerSchema(BaseIOSchema):
    """Schema for the final answer generated by the Web Search Agent."""
    final_answer: str = Field(..., description="The final answer generated based on the search results and user query.")


#######################
# AGENT CONFIGURATION #
#######################

class WebSearchAgentConfig(BaseAgentConfig):
    """Configuration for the Web Search Agent."""
    # Include configurations for tools the agent might use
    duckduckgo_search_config: DuckDuckGoSearchToolConfig = Field(default_factory=DuckDuckGoSearchToolConfig)
    webpage_scraper_config: WebpageScraperToolConfig = Field(default_factory=WebpageScraperToolConfig)


#####################
# SYSTEM PROMPTS    #
#####################

# System prompt for the first step: Generating search queries
search_query_system_prompt = SystemPromptGenerator(
    background=[
        "You are an expert web search agent designed to assist users by performing web searches.",
        "Your first task is to analyze the user's query and determine the best search terms to find relevant information.",
        "You have access to a DuckDuckGo search tool.",
    ],
    output_instructions=[
        "Analyze the user's query carefully.",
        "Formulate 1 to 3 precise and effective search queries.",
        "Specify the maximum number of results you need for each query (recommend 3-5 for conciseness).",
        "Format your output strictly according to the DuckDuckGoSearchToolInputSchema.",
        "Do NOT attempt to answer the question yet. Just provide the search queries.",
        "Ensure the 'queries' field is a list of strings.",
        "Ensure the 'max_results' field is an integer.",
    ],
)

# System prompt for the second step: Synthesizing the final answer
# This prompt will be used after search results are added to memory.
final_answer_system_prompt = SystemPromptGenerator(
    background=[
        "You are an expert web search agent.",
        "You have just performed a web search based on the user's original query.",
        "The search results are available in the conversation history marked as 'tool_output'.",
        "Your task is to read the search results and the user's original query to synthesize a concise and accurate final answer.",
    ],
    output_instructions=[
        "Review the provided search results in your memory.",
        "Identify the key information relevant to the user's original query.",
        "Synthesize the information into a clear, well-structured answer.",
        "If the search results do not contain a clear answer, state that you couldn't find a definitive answer based on the search.",
        "Do not include URLs or reference the search results explicitly unless necessary for context (e.g., 'According to search results...').",
        "Format your final answer strictly according to the FinalAnswerSchema.",
    ],
)


######################
# WEB SEARCH AGENT #
######################

# Initialize the agent with the system prompt for the first step and the corresponding output schema
# The agent's config includes the tool configs, but the tools are executed externally.
web_search_agent = BaseAgent(
    BaseAgentConfig(
        client=client,
        model="gpt-4o-mini",  # Use a suitable model
        system_prompt_generator=search_query_system_prompt, # Agent starts by generating search queries
        input_schema=WebSearchAgentInputSchema,
        output_schema=DuckDuckGoSearchToolInputSchema, # Agent's first output format
        memory=AgentMemory(), # Initialize memory to pass information between steps
    )
)


#################
# EXAMPLE USAGE #
#################

if __name__ == "__main__":
    console = Console()

    # Initialize the tools. Tools are instantiated here, outside the agent's
    # core logic, because they are executed externally.
    duckduckgo_search_tool = DuckDuckGoSearchTool(DuckDuckGoSearchToolConfig(max_results=5))
    webpage_scraper_tool = WebpageScraperTool(WebpageScraperToolConfig()) # Instantiate, but not used in this example's flow yet

    # Example inputs
    user_inputs = [
        "What is the capital of France?",
        "Who won the last FIFA World Cup?",
        "Tell me about the latest discoveries in quantum physics.",
    ]

    for user_input_query in user_inputs:
        console.print(Panel(f"[bold cyan]User Input:[/bold cyan] {user_input_query}", expand=False))

        # --- Step 1: Agent generates search queries ---
        console.print("\n[bold yellow]Step 1: Agent generating search queries...[/bold yellow]")

        # Set the agent's state for step 1
        web_search_agent.config.system_prompt_generator = search_query_system_prompt
        web_search_agent.output_schema = DuckDuckGoSearchToolInputSchema
        web_search_agent.memory = AgentMemory() # Clear memory for a new query

        # Create the input schema for the agent's first run
        agent_input_step1 = WebSearchAgentInputSchema(query=user_input_query)

        # Run the agent to get the search tool input parameters
        try:
            search_tool_params: DuckDuckGoSearchToolInputSchema = web_search_agent.run(agent_input_step1)

            # Print the generated search parameters
            console.print("\n[bold magenta]Generated Search Parameters:[/bold magenta]")
            search_params_syntax = Syntax(
                str(search_tool_params.model_dump_json(indent=2)), "json", theme="monokai", line_numbers=True
            )
            console.print(search_params_syntax)

        except Exception as e:
             console.print(f"[red]Error during search query generation:[/red] {str(e)}")
             # If query generation fails, we cannot proceed
             continue # Move to the next user input

        # --- Step 2: Execute the search tool ---
        console.print("\n[bold yellow]Step 2: Executing search tool...[/bold yellow]")
        search_results = None # Initialize search_results
        try:
            # Execute the search tool with the parameters generated by the agent
            # We use search_type="text" as the default for general queries.
            # A more complex agent might determine search type.
            search_results: DuckDuckGoSearchToolOutputSchema = duckduckgo_search_tool.run(search_tool_params, search_type="text")

            # Print the search results
            console.print("\n[bold green]Search Results:[/bold green]")
            search_results_syntax = Syntax(
                str(search_results.model_dump_json(indent=2)), "json", theme="monokai", line_numbers=True
            )
            console.print(search_results_syntax)

        except Exception as e:
            console.print(f"[red]Error during search execution:[/red] {str(e)}")
            # Add the error to memory so the agent knows search failed
            web_search_agent.memory.add_message("tool_error", f"Search failed: {e}")


        # --- Step 3: Agent generates the final answer based on search results ---
        console.print("\n[bold yellow]Step 3: Agent generating final answer...[/bold yellow]")

        # Add the search results (or indication of error) to the agent's memory
        # This allows the agent to 'see' the tool's output for the next step.
        if search_results:
            # Add tool output structured clearly
            web_search_agent.memory.add_message("tool_output", search_results.model_dump_json(indent=2))
        # If search_results is None, the tool_error message was already added in the except block

        # Change the agent's system prompt and output schema for the final answer generation
        web_search_agent.config.system_prompt_generator = final_answer_system_prompt
        web_search_agent.output_schema = FinalAnswerSchema

        # Run the agent again using the original input.
        # The agent will now use its new system prompt and the memory containing search results.
        try:
            final_answer_output: FinalAnswerSchema = web_search_agent.run(agent_input_step1)

            # Print the final answer
            console.print("\n[bold blue]Final Answer:[/bold blue]")
            console.print(final_answer_output.final_answer)

        except Exception as e:
            console.print(f"[red]Error during final answer generation:[/red] {str(e)}")

        finally:
            # Clean up memory for the next turn. The system prompt and output schema
            # are reset at the beginning of the loop for the next user query.
            pass # Memory reset and schema/prompt changes happen at the start of the loop


        console.print("\n" + "=" * 80 + "\n") # Separator for the next query
